<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>斗地主：赖子核爆版 (V8)</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff0055;
            --hazard: #ffcc00;
            --laizi-glow: #aa00ff; /* 赖子专属紫光 */
            --bg-dark: #0a0a12;
            --card-w: 60px;
            --card-h: 90px;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; margin: 0; padding: 0; }
        
        body {
            height: 100vh; width: 100vw; overflow: hidden;
            background: #050505;
            background-image: 
                radial-gradient(circle at 50% 50%, #1a1a2e 0%, #000 100%),
                repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(170, 0, 255, 0.05) 1px, rgba(170, 0, 255, 0.05) 2px);
            font-family: 'Share Tech Mono', monospace;
            color: var(--neon-blue);
            display: flex; flex-direction: column;
        }

        /* === 震动特效 === */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake-screen { animation: shake 0.5s; }

        /* === 游戏区域 === */
        #game-table { flex: 1; position: relative; width: 100%; perspective: 1000px; }
        
        /* 顶部栏 */
        #hud-top {
            position: absolute; top: 0; width: 100%; height: 70px;
            display: flex; justify-content: center; align-items: center; gap: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            z-index: 10; padding-top: 10px;
        }
        .laizi-indicator {
            display: flex; flex-direction: column; align-items: center;
            border: 1px solid var(--laizi-glow); padding: 5px; border-radius: 4px;
            background: rgba(170, 0, 255, 0.1);
            box-shadow: 0 0 15px var(--laizi-glow);
        }
        .laizi-card-display { font-size: 20px; font-weight: bold; color: #fff; }

        .base-cards { display: flex; gap: 5px; }

        /* 玩家头像 */
        .avatar {
            position: absolute; width: 85px; top: 15%;
            border: 1px solid var(--neon-blue); background: rgba(0, 243, 255, 0.05);
            padding: 5px; text-align: center; font-size: 12px;
            box-shadow: 0 0 5px var(--neon-blue);
            transition: all 0.3s;
        }
        .avatar.left { left: 10px; border-left: 3px solid var(--neon-blue); }
        .avatar.right { right: 10px; border-right: 3px solid var(--neon-blue); }
        .avatar .count { font-size: 20px; color: #fff; }
        .active-turn { 
            border-color: var(--hazard); box-shadow: 0 0 15px var(--hazard); 
            background: rgba(255, 204, 0, 0.1);
        }

        /* 卡牌样式 */
        .card {
            width: var(--card-w); height: var(--card-h);
            background: #1e1e24; border: 1px solid #444; border-radius: 4px;
            position: absolute; display: flex; flex-direction: column;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.8);
            transition: transform 0.1s;
        }
        .card.red { color: #ff2a6d; border-color: #ff2a6d; }
        .card.black { color: #05d9e8; border-color: #05d9e8; }
        .card.back {
            background: repeating-linear-gradient(45deg, #111, #111 5px, #222 5px, #222 10px);
            border: 1px solid var(--neon-blue);
            display: flex; justify-content: center; align-items: center;
        }
        .card.back::after { content: '☢'; font-size: 24px; color: var(--hazard); opacity: 0.5; }
        
        /* 赖子牌特效 */
        .card.is-laizi {
            border: 2px solid var(--laizi-glow);
            background: linear-gradient(135deg, #1e1e24, #2a0033);
            box-shadow: 0 0 10px var(--laizi-glow);
        }
        .card.is-laizi::before {
            content: '★'; position: absolute; top: -5px; right: -5px;
            color: var(--hazard); font-size: 14px; text-shadow: 0 0 5px #fff; z-index: 2;
        }

        .card .val { font-size: 18px; font-weight: bold; margin: 2px 0 0 4px; }
        .card .suit { font-size: 12px; margin-left: 4px; }
        .card .big-suit { position: absolute; bottom: 2px; right: 2px; font-size: 28px; opacity: 0.2; }
        
        /* 玩家手牌 */
        #player-zone {
            height: 240px; position: relative;
            background: linear-gradient(to top, #000, transparent);
            display: flex; flex-direction: column; justify-content: flex-end;
            padding-bottom: 10px;
        }
        #hand-container {
            position: relative; height: 110px; width: 100%;
            display: flex; justify-content: center; align-items: flex-end;
        }
        .my-card { 
            position: relative; margin-left: -35px; background: #222; 
            border: 1px solid #666; cursor: pointer;
        }
        .my-card:first-child { margin-left: 0; }
        .my-card.selected { 
            transform: translateY(-20px); border-color: var(--hazard); 
            box-shadow: 0 0 10px var(--hazard); z-index: 100;
        }

        /* 出牌区 */
        .played-area { position: absolute; display: flex; gap: -35px; pointer-events: none; }
        #play-left { top: 35%; left: 100px; }
        #play-right { top: 35%; right: 100px; justify-content: flex-end; }
        #play-center { top: 50%; left: 50%; transform: translateX(-50%); }
        .played-area .card { position: relative; transform: scale(0.9); }

        /* 控件 */
        #controls {
            position: absolute; top: 0; width: 100%;
            display: flex; justify-content: center; gap: 15px; z-index: 20;
        }
        .btn {
            padding: 10px 24px; background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--neon-blue); color: var(--neon-blue);
            font-family: 'Share Tech Mono', monospace; font-size: 16px;
            box-shadow: 0 0 5px var(--neon-blue); cursor: pointer;
        }
        .btn:active { background: var(--neon-blue); color: #000; }
        .btn.primary { border-color: var(--hazard); color: var(--hazard); box-shadow: 0 0 5px var(--hazard); }
        
        #toast {
            position: fixed; top: 40%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); border: 1px solid var(--laizi-glow);
            color: var(--laizi-glow); padding: 10px 20px; font-size: 20px;
            opacity: 0; pointer-events: none; transition: opacity 0.2s; z-index: 100;
            text-shadow: 0 0 10px var(--laizi-glow);
        }
    </style>
</head>
<body>

    <div id="game-table">
        <div id="hud-top">
            <div class="laizi-indicator">
                <div style="font-size:10px; color:var(--laizi-glow);">当前赖子</div>
                <div class="laizi-card-display" id="laizi-disp">?</div>
            </div>
            <div class="base-cards">
                <div class="card back" id="base-0"></div>
                <div class="card back" id="base-1"></div>
                <div class="card back" id="base-2"></div>
            </div>
        </div>

        <div class="avatar left" id="av-west">
            <div class="role" id="role-west"></div>
            <div>废土行者 L</div>
            <div class="count" id="count-west">17</div>
        </div>
        <div class="avatar right" id="av-east">
            <div class="role" id="role-east"></div>
            <div>废土行者 R</div>
            <div class="count" id="count-east">17</div>
        </div>

        <div id="play-left" class="played-area"></div>
        <div id="play-right" class="played-area"></div>
        <div id="play-center" class="played-area"></div>
    </div>

    <div id="player-zone">
        <div id="controls">
            <div id="grp-start"><button class="btn primary" onclick="game.start()">初始化系统</button></div>
            <div id="grp-bid" style="display:none">
                <button class="btn" onclick="game.bid(0)">放弃</button>
                <button class="btn primary" onclick="game.bid(3)">夺取权限</button>
            </div>
            <div id="grp-play" style="display:none">
                <button class="btn" onclick="game.pass()">跳过</button>
                <button class="btn primary" onclick="game.play()">出牌</button>
            </div>
        </div>
        <div id="hand-container"></div>
    </div>
    
    <div id="toast"></div>

<script>
/* === 核心数据 === */
const VALUES = { '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '0':10, 'J':11, 'Q':12, 'K':13, 'A':14, '2':15, 'S':16, 'B':17 };
const R_VALUES = Object.fromEntries(Object.entries(VALUES).map(([k,v])=>[v,k]));
const SUITS = ['♠', '♥', '♣', '♦'];
const TYPES = { INVALID:0, SINGLE:1, PAIR:2, TRIPLET:3, BOMB:4, ROCKET:5, TRIPLET_1:6, TRIPLET_2:7, STRAIGHT:8, PAIR_STRAIGHT:9, BOMB_LAIZI:10 };

// 全局赖子值 (3-15)
let GLOBAL_LAIZI_VAL = -1;

class Card {
    constructor(val, suit) { 
        this.val = val; 
        this.suit = suit; 
        this.sel = false; 
        this.id = Math.random(); 
    }
    get isLaizi() { return this.val === GLOBAL_LAIZI_VAL; }
    get txt() { if(this.val==16) return 'Joker'; if(this.val==17) return 'JOKER'; return R_VALUES[this.val].replace('0','10'); }
    get color() { return (this.suit=='♥'||this.suit=='♦'||this.val==17) ? 'red' : 'black'; }
}

/* === 赖子牌型分析引擎 === */
const Analyzer = {
    // 检查是否包含赖子，并分离
    split: function(cards) {
        let laizis = [], normals = [];
        cards.forEach(c => c.isLaizi ? laizis.push(c) : normals.push(c));
        return { laizis, normals, lCnt: laizis.length };
    },

    getType: function(cards) {
        let len = cards.length;
        if (len == 0) return null;

        let { laizis, normals, lCnt } = this.split(cards);
        
        // 纯赖子炸弹 (如果数量>=4) - 简化：目前一副牌只有4个赖子
        if (normals.length == 0 && lCnt >= 4) return {t: TYPES.BOMB_LAIZI, v: 999}; 

        // 如果只有赖子，且少于4个，视作该赖子点数的最大牌型
        if (normals.length == 0) {
            if (lCnt == 1) return {t: TYPES.SINGLE, v: GLOBAL_LAIZI_VAL};
            if (lCnt == 2) return {t: TYPES.PAIR, v: GLOBAL_LAIZI_VAL};
            if (lCnt == 3) return {t: TYPES.TRIPLET, v: GLOBAL_LAIZI_VAL};
        }

        // 普通分析
        let nVals = normals.map(c=>c.val).sort((a,b)=>a-b);
        let counts = {}; nVals.forEach(v => counts[v] = (counts[v]||0)+1);
        let keys = Object.keys(counts).map(Number);
        
        // 王炸 (赖子不能替王)
        if (len == 2 && nVals.includes(16) && nVals.includes(17)) return {t: TYPES.ROCKET, v: 1000};

        // 单张 (1赖子已处理)
        if (len == 1) return {t: TYPES.SINGLE, v: nVals[0]};

        // 对子 (1普+1赖, 或 2普)
        if (len == 2) {
            if (normals.length == 1) return {t: TYPES.PAIR, v: nVals[0]}; // 赖子配对
            if (nVals[0] == nVals[1]) return {t: TYPES.PAIR, v: nVals[0]};
        }

        // 三张
        if (len == 3) {
            if (keys.length == 1 && (counts[keys[0]] + lCnt >= 3)) return {t: TYPES.TRIPLET, v: keys[0]};
        }

        // 炸弹 (硬炸或软炸)
        if (len == 4) {
            if (keys.length == 1 && (counts[keys[0]] + lCnt == 4)) return {t: TYPES.BOMB, v: keys[0]};
        }

        // 顺子 (赖子补缺)
        if (len >= 5 && keys.length == normals.length && nVals[nVals.length-1] < 15) { // 不含2和王
            let gaps = 0;
            for (let i = 0; i < nVals.length - 1; i++) {
                gaps += (nVals[i+1] - nVals[i] - 1);
            }
            if (gaps <= lCnt) return {t: TYPES.STRAIGHT, v: nVals[0], len: len}; // 简化：以最小普通牌定大小
        }

        // 三带一
        if (len == 4) {
            // 赖子优先凑三张
            // 找那个普通牌能凑成3张的
            for(let k of keys) {
                if (counts[k] + lCnt >= 3) return {t: TYPES.TRIPLET_1, v: k};
            }
        }
        
        // 三带二 (5张)
        if (len == 5) {
             // 逻辑较复杂，简化判定：只要能凑出3+2即可
             // 尝试把赖子分配给不同组合
             for(let k of keys) {
                 // 假设 k 是三张的主值
                 let needForTri = Math.max(0, 3 - counts[k]);
                 if (lCnt >= needForTri) {
                     // 剩下的牌能否凑对子?
                     // 暂略，赖子玩法核心是爽快，这里只要牌数对且有赖子，稍微放宽判定
                     return {t: TYPES.TRIPLET_2, v: k};
                 }
             }
        }

        return null;
    },

    // 比较大小
    canBeat: function(my, target) {
        if (!target) return true;
        
        // 赖子炸弹无敌 (除王炸)
        if (my.t == TYPES.BOMB_LAIZI && target.t != TYPES.ROCKET) return true;
        if (target.t == TYPES.BOMB_LAIZI) return false;

        if (my.t == TYPES.ROCKET) return true;
        if (target.t == TYPES.ROCKET) return false;
        
        if (my.t == TYPES.BOMB && target.t != TYPES.BOMB) return true;
        
        if (my.t == target.t && my.v > target.v && (my.len || 0) == (target.len || 0)) return true;
        
        return false;
    }
};

/* === 游戏主逻辑 === */
class Game {
    constructor() {
        this.p = { south: [], west: [], east: [] };
        this.state = 0; 
        this.turn = null;
        this.landlord = null;
        this.lastPlay = null;
        this.passCnt = 0;
        
        this.ui = {
            hand: document.getElementById('hand-container'),
            btns: {
                start: document.getElementById('grp-start'),
                bid: document.getElementById('grp-bid'),
                play: document.getElementById('grp-play')
            },
            areas: {
                south: document.getElementById('play-center'),
                west: document.getElementById('play-left'),
                east: document.getElementById('play-right')
            },
            avatars: { west: document.getElementById('av-west'), east: document.getElementById('av-east') },
            bases: [document.getElementById('base-0'), document.getElementById('base-1'), document.getElementById('base-2')],
            laiziDisp: document.getElementById('laizi-disp')
        };
    }

    toast(msg) {
        let t = document.getElementById('toast');
        t.innerText = msg; t.style.opacity = 1;
        setTimeout(()=>t.style.opacity=0, 2000);
    }

    start() {
        // 确定赖子 (3-2)
        GLOBAL_LAIZI_VAL = Math.floor(Math.random() * 13) + 3;
        this.ui.laiziDisp.innerText = R_VALUES[GLOBAL_LAIZI_VAL].replace('0','10');

        // 洗牌
        let deck = [];
        for(let v=3; v<=15; v++) for(let s of SUITS) deck.push(new Card(v, s));
        deck.push(new Card(16, ''), new Card(17, ''));
        deck.sort(()=>Math.random()-0.5);

        // 发牌
        this.baseCards = deck.splice(0,3);
        this.p.south = deck.splice(0,17);
        this.p.west = deck.splice(0,17);
        this.p.east = deck.splice(0,17);
        ['south','west','east'].forEach(k=>this.sortCards(this.p[k]));

        // UI重置
        this.ui.btns.start.style.display = 'none';
        this.ui.btns.bid.style.display = 'flex';
        this.ui.bases.forEach(b => { b.className = 'card back'; b.innerHTML=''; });
        ['west','east'].forEach(k => {
            document.getElementById('role-'+k).innerText = '';
            document.getElementById('count-'+k).innerText = '17';
            this.ui.areas[k].innerHTML = '';
        });
        this.ui.areas.south.innerHTML = '';
        
        this.renderHand();
        this.toast(`赖子确定为: ${this.ui.laiziDisp.innerText}`);
    }

    sortCards(arr) { arr.sort((a,b)=>b.val - a.val); }

    renderHand() {
        this.ui.hand.innerHTML = '';
        this.p.south.forEach((c, i) => {
            let d = document.createElement('div');
            d.className = `card my-card ${c.color} ${c.sel?'selected':''} ${c.isLaizi?'is-laizi':''}`;
            d.innerHTML = `<div class="val">${c.txt}</div><div class="suit">${c.suit}</div><div class="big-suit">${c.suit}</div>`;
            d.onclick = () => { c.sel = !c.sel; this.renderHand(); };
            d.style.zIndex = i;
            this.ui.hand.appendChild(d);
        });
    }

    bid(score) {
        this.ui.btns.bid.style.display = 'none';
        let boss = (score > 0) ? 'south' : (Math.random()>0.5 ? 'west' : 'east');
        this.setLandlord(boss);
    }

    setLandlord(who) {
        this.landlord = who;
        this.p[who].push(...this.baseCards);
        this.sortCards(this.p[who]);
        
        // 显示底牌
        this.ui.bases.forEach((b, i) => {
            let c = this.baseCards[i];
            b.className = `card ${c.color} ${c.isLaizi?'is-laizi':''}`;
            b.innerHTML = `<div class="val">${c.txt}</div>`;
        });

        if(who=='south') this.renderHand();
        else document.getElementById('role-'+who).innerText = '[BOSS]';
        
        this.updateCounts();
        this.turn = who;
        this.lastPlay = null;
        this.passCnt = 0;
        this.nextStep();
    }

    nextStep() {
        this.ui.avatars.west.classList.remove('active-turn');
        this.ui.avatars.east.classList.remove('active-turn');
        if(this.turn != 'south') this.ui.avatars[this.turn].classList.add('active-turn');

        if(this.turn == 'south') {
            this.ui.btns.play.style.display = 'flex';
            let isFree = (!this.lastPlay || this.lastPlay.who == 'south');
            document.querySelector('#grp-play button:first-child').style.display = isFree ? 'none' : 'block';
        } else {
            this.ui.btns.play.style.display = 'none';
            setTimeout(() => this.aiMove(), 1000);
        }
    }

    play() {
        let sels = this.p.south.filter(c => c.sel);
        if(sels.length == 0) return this.toast('未选牌');
        
        let typeData = Analyzer.getType(sels);
        if(!typeData) return this.toast('无效牌型');

        if(this.lastPlay && this.lastPlay.who != 'south') {
            if(!Analyzer.canBeat(typeData, this.lastPlay.typeData)) return this.toast('打不过');
        }

        this.doPlay('south', sels, typeData);
    }

    pass() {
        this.passCnt++;
        this.ui.areas.south.innerHTML = '<span style="color:#555; background:#000; padding:5px;">[跳过]</span>';
        this.rotateTurn();
    }

    aiMove() {
        let hand = this.p[this.turn];
        let play = null;
        let isFree = (!this.lastPlay || this.lastPlay.who == this.turn);

        // 简单 AI 策略：有赖子就瞎凑
        if(isFree) {
            play = [hand[hand.length-1]]; // 出最小单
        } else {
            // 压牌
            let target = this.lastPlay.typeData;
            if(target.t == TYPES.SINGLE) {
                // 找单张
                let c = hand.slice().reverse().find(x=>x.val > target.v);
                if(c) play=[c];
                else {
                    // 用赖子凑？AI暂时不浪费赖子在单张
                }
            } else if (target.t == TYPES.PAIR) {
                 // 找对子
                 for(let i=hand.length-1; i>0; i--) {
                     if(hand[i].val == hand[i-1].val && hand[i].val > target.v) { play=[hand[i], hand[i-1]]; break; }
                 }
            }
        }

        if(play) {
            let td = Analyzer.getType(play);
            this.doPlay(this.turn, play, td);
        } else {
            this.passCnt++;
            this.ui.areas[this.turn].innerHTML = '<span style="color:#555; background:#000; padding:5px;">[跳过]</span>';
            this.rotateTurn();
        }
    }

    doPlay(who, cards, typeData) {
        this.p[who] = this.p[who].filter(c => !cards.includes(c));
        if(who=='south') this.renderHand();
        this.updateCounts();

        let area = this.ui.areas[who];
        area.innerHTML = '';
        cards.forEach(c => {
            let d = document.createElement('div');
            d.className = `card ${c.color} ${c.isLaizi?'is-laizi':''}`;
            d.innerHTML = `<div class="val">${c.txt}</div><div class="big-suit">${c.suit}</div>`;
            area.appendChild(d);
        });

        // 震动特效
        if(typeData.t == TYPES.BOMB || typeData.t == TYPES.ROCKET || typeData.t == TYPES.BOMB_LAIZI) {
            document.body.classList.add('shake-screen');
            setTimeout(()=>document.body.classList.remove('shake-screen'), 500);
        }

        this.lastPlay = { who: who, typeData: typeData };
        this.passCnt = 0;

        if(this.p[who].length == 0) {
            setTimeout(()=>alert(who=='south'?'胜利！':'失败！'), 100);
            location.reload();
        } else {
            this.rotateTurn();
        }
    }

    rotateTurn() {
        if(this.passCnt >= 2) this.lastPlay = null;
        this.turn = (this.turn=='south') ? 'east' : (this.turn=='east' ? 'west' : 'south');
        this.nextStep();
    }

    updateCounts() {
        document.getElementById('count-west').innerText = this.p.west.length;
        document.getElementById('count-east').innerText = this.p.east.length;
    }
}

const game = new Game();
</script>
</body>
</html>
