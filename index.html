<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ–—åœ°ä¸»ï¼šæœ«æ—¥åºŸåœŸç”Ÿå­˜ç‰ˆ (V5)</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
/* ============================================== */
/* æ ·å¼éƒ¨åˆ† (çº¦ 700 è¡Œ) - èµ›åšæœ‹å…‹/åºŸåœŸä¸»é¢˜ */
/* ============================================== */

        :root {
            /* èµ›åšæœ‹å…‹ä¸»é¢˜è‰² */
            --color-neon-blue: #00e0ff;
            --color-neon-pink: #ff1080;
            --color-bg-dark: #12121e;
            --color-metal-dark: #222233;
            --color-hazard-yellow: #ffc400;
            --card-width: 56px;
            --card-height: 84px;
        }

        * { 
            box-sizing: border-box; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            margin: 0; 
            padding: 0;
            transition: all 0.2s ease-out;
        }

        body {
            height: 100vh;
            width: 100vw;
            /* åºŸåœŸé‡‘å±èƒŒæ™¯ */
            background: 
                linear-gradient(rgba(18, 18, 30, 0.9), rgba(18, 18, 30, 0.9)),
                repeating-linear-gradient(45deg, var(--color-metal-dark), var(--color-metal-dark) 2px, #1c1c28 3px, #1c1c28 5px);
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- æ¸¸æˆæ¡Œé¢ --- */
        #game-table {
            flex: 1;
            position: relative;
            width: 100%;
            perspective: 1000px;
        }

        /* é¡¶éƒ¨ HUD/åº•ç‰ŒåŒº */
        #top-bar {
            position: absolute;
            top: 15px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 8px;
            z-index: 10;
        }

        /* ç©å®¶å¤´åƒå’Œä¿¡æ¯ - èµ›åšæœ‹å…‹ HUD */
        .player-avatar {
            position: absolute;
            top: 10%;
            width: 100px;
            padding: 8px;
            border: 1px solid var(--color-neon-blue);
            background: rgba(0, 224, 255, 0.1);
            border-radius: 4px;
            box-shadow: 0 0 10px var(--color-neon-blue);
            text-shadow: 0 0 5px #000;
            transition: all 0.5s;
        }
        .player-avatar.left { left: 10px; }
        .player-avatar.right { right: 10px; }
        
        .avatar-icon {
            width: 40px; height: 40px; background: var(--color-hazard-yellow); border-radius: 50%;
            margin-bottom: 5px; display: flex; justify-content: center; align-items: center;
            font-size: 20px; color: var(--color-bg-dark); font-weight: bold;
        }
        .avatar-info { color: white; font-size: 10px; line-height: 1.4; }
        .role-badge { 
            font-size: 10px; padding: 2px 4px; border-radius: 2px; margin-top: 4px; 
            background: var(--color-neon-pink); color: white; font-weight: bold;
            box-shadow: 0 0 5px var(--color-neon-pink);
        }
        .stat-line { 
            display: flex; justify-content: space-between; 
            font-size: 10px; margin-top: 2px;
            color: var(--color-neon-blue);
        }

        /* è½®æµæŒ‡ç¤ºå™¨ï¼šæ•…éšœ/Glitch åŠ¨ç”» */
        .active-turn { 
            border: 2px solid var(--color-hazard-yellow); 
            box-shadow: 0 0 15px var(--color-hazard-yellow); 
            animation: glitch 1.5s infinite alternate;
        }
        @keyframes glitch { 
            0% { transform: translate(1px, 1px); filter: brightness(1); }
            50% { transform: translate(-1px, 0px); filter: brightness(1.2); }
            100% { transform: translate(0px, -1px); filter: brightness(1); }
        }

        /* --- ç‰Œé¢æ ·å¼ (èµ„æºå¡) --- */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.6);
            position: relative;
            display: block;
            padding: 4px;
            border: 1px solid #aaa;
        }

        .card.back {
            background: linear-gradient(135deg, var(--color-neon-blue), var(--color-metal-dark));
            border: 2px solid var(--color-neon-pink);
            background-image: radial-gradient(circle, rgba(255,255,255,0.1) 10%, transparent 11%);
            background-size: 15px 15px;
            box-shadow: 0 0 10px rgba(0, 224, 255, 0.5);
        }
        
        .card.red { color: var(--color-neon-pink); }
        .card.black { color: var(--color-neon-blue); }

        /* å·¦ä¸Šè§’å’Œå³ä¸‹è§’å®šä½ */
        .card .rank-corner { 
            position: absolute; top: 4px; left: 4px; 
            font-weight: bold; font-size: 16px; 
        }
        .card .big-suit { 
            position: absolute; bottom: 4px; right: 4px; 
            font-size: 16px; 
            transform: rotate(180deg);
        }

        /* æ±¡æŸ“ç‰Œ (Joker/ç‹ç‰Œ) æ•ˆæœ */
        .card.mutant {
            background: linear-gradient(45deg, #4d1d1d, #2d2d00);
            border: 3px dashed var(--color-hazard-yellow);
            color: var(--color-hazard-yellow);
            animation: radiation-pulse 2s infinite alternate;
        }
        @keyframes radiation-pulse {
            from { box-shadow: 0 0 5px var(--color-hazard-yellow); }
            to { box-shadow: 0 0 15px var(--color-hazard-yellow); }
        }

        /* --- æ‰‹ç‰Œå®¹å™¨å’Œäº¤äº’ --- */
        #player-zone {
            height: 270px; 
            position: relative;
            background: linear-gradient(to top, rgba(18, 18, 30, 0.8), transparent);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: 20px;
        }

        #hand-container {
            position: relative;
            height: 180px; 
            width: 100%;
            display: flex;
            justify-content: center; 
            align-items: flex-end;
        }
        
        .my-card {
            position: relative;
            transform-origin: 50% 120%;
            margin-left: -40px; /* é»˜è®¤é‡å  */
        }
        .my-card:first-child { margin-left: 0; }
        
        .my-card.selected {
            transform: translateY(-30px) !important; 
            z-index: 100 !important;
            border: 3px solid var(--color-neon-blue);
            box-shadow: 0 0 15px var(--color-neon-blue);
        }

        /* --- æŒ‰é’®å’Œ HUD å…ƒç´  --- */
        .btn {
            background: var(--color-neon-blue);
            color: var(--color-bg-dark);
            font-weight: bold;
            box-shadow: 0 4px 0 #0099ff, 0 8px 10px rgba(0,0,0,0.4);
            /* å…¶ä»–åŸºç¡€æ ·å¼... */
        }
        .btn.pink { 
            background: var(--color-neon-pink); 
            box-shadow: 0 4px 0 #cc0066;
        }
        
        /* æ‰«ææ¨¡å¼ HUD (é«˜äº®æç¤º) */
        #scan-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            padding: 20px;
        }
        .scan-result {
            border: 1px dashed var(--color-neon-blue);
            padding: 10px; margin: 5px;
            font-size: 14px;
        }

/* ============================================== */
/* JS é€»è¾‘éƒ¨åˆ† (çº¦ 1300 è¡Œ) - æ ¸å¿ƒæœºåˆ¶ä¸ AI */
/* ============================================== */
    </style>
</head>
<body>

    <div id="game-table">
        <div id="top-bar">
            <div class="card back" id="base-1"></div>
            <div class="card back" id="base-2"></div>
            <div class="card back" id="base-3"></div>
        </div>

        <div class="player-avatar left" id="avatar-west">
            <div class="avatar-icon">ğŸ¤–</div>
            <div class="avatar-info">
                <div>æ‹¾è’è€… (å·¦)</div>
                <div class="stat-line">
                    <span>æ‰‹ç‰Œ:</span> <span id="count-west">17</span>
                </div>
                <div class="stat-line">
                    <span>æ±¡æŸ“å€¼:</span> <span id="mut-west">0</span>
                </div>
                <div class="role-badge" id="role-west" style="display:none"></div>
            </div>
        </div>

        <div class="player-avatar right" id="avatar-east">
            <div class="avatar-icon">ğŸ¤ </div>
            <div class="avatar-info">
                <div>æœºæ¢°å¸ˆ (å³)</div>
                <div class="stat-line">
                    <span>æ‰‹ç‰Œ:</span> <span id="count-east">17</span>
                </div>
                <div class="stat-line">
                    <span>æ±¡æŸ“å€¼:</span> <span id="mut-east">0</span>
                </div>
                <div class="role-badge" id="role-east" style="display:none"></div>
            </div>
        </div>

        <div id="play-left" class="played-area"></div>
        <div id="play-right" class="played-area"></div>
        <div id="play-center" class="played-area"></div>
    </div>

    <div id="player-zone">
        <div id="msg-toast">ç³»ç»Ÿå¯åŠ¨ä¸­...</div>
        
        <div id="controls">
            <button class="btn pink" id="btn-start" onclick="game.init()">å¼€å§‹åºŸåœŸæ—…ç¨‹</button>
            
            <div id="group-bid" style="display:none; gap:15px;">
                <button class="btn pink" onclick="game.playerBid(true)">äº‰å¤ºåœ°ä¸»</button>
                <button class="btn" onclick="game.playerBid(false)">æ”¾å¼ƒ</button>
            </div>

            <div id="group-play" style="display:none; gap:15px;">
                <button class="btn" id="btn-scan" onmousedown="game.startScan()" onmouseup="game.stopScan()" ontouchstart="game.startScan()" ontouchend="game.stopScan()">
                    æ‰«æ
                </button>
                <button class="btn" id="btn-pass" onclick="game.playerPass()">å¼ƒç‰Œ</button>
                <button class="btn pink" id="btn-submit" onclick="game.playerPlay()">å‡ºç‰Œ</button>
            </div>
        </div>

        <div id="hand-container"></div>
    </div>
    
    <div id="scan-overlay" onclick="game.hideScanOverlay()">
        <h3 style="color:var(--color-hazard-yellow); margin-bottom: 20px;">:: ç”Ÿå­˜æ‰«ææ¨¡å¼ ::</h3>
        <div id="scan-results-container">
            </div>
    </div>

<script>
// ====================================================================
// JS CORE START
// ====================================================================

const SUITS = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
const RANKS = ['3','4','5','6','7','8','9','10','J','Q','K','A','2'];
const PLAYER_IDS = ['south', 'east', 'west'];

class Card {
    constructor(val, suit = '', type = 'normal') {
        this.val = val; 
        this.suit = suit;
        this.type = type; 
        this.selected = false;
        this.id = Math.random().toString(36).substr(2, 9);
        this.isMutant = false; // æ±¡æŸ“ç‰Œæ ‡è®°
    }
    
    get display() {
        if (this.val === 16) return 'SJ'; // Small Joker -> Small Junk
        if (this.val === 17) return 'BJ'; // Big Joker -> Big Junk
        return RANKS[this.val - 3];
    }

    get color() {
        if (this.suit === 'â™¥' || this.suit === 'â™¦' || this.val === 17) return 'red';
        return 'black';
    }
}

class Game {
    constructor() {
        this.reset();
        this.setupElements();
        this.scanTimeout = null;
    }
    
    setupElements() {
        // ... (DOM Element setup remains the same, simplified for brevity)
        this.els = {
            hand: document.getElementById('hand-container'),
            controls: {
                start: document.getElementById('btn-start'),
                bid: document.getElementById('group-bid'),
                play: document.getElementById('group-play'),
                pass: document.getElementById('btn-pass'),
                scan: document.getElementById('btn-scan')
            },
            played: {
                west: document.getElementById('play-left'),
                east: document.getElementById('play-right'),
                south: document.getElementById('play-center')
            },
            base: [document.getElementById('base-1'), document.getElementById('base-2'), document.getElementById('base-3')],
            counts: { west: document.getElementById('count-west'), east: document.getElementById('count-east') },
            badges: { west: document.getElementById('role-west'), east: document.getElementById('role-east') },
            mutations: { west: document.getElementById('mut-west'), east: document.getElementById('mut-east') },
            toast: document.getElementById('msg-toast'),
            avatars: { west: document.getElementById('avatar-west'), east: document.getElementById('avatar-east') },
            scanOverlay: document.getElementById('scan-overlay'),
            scanResults: document.getElementById('scan-results-container')
        };
    }

    reset() {
        this.deck = [];
        this.hands = { south: [], west: [], east: [] };
        this.mutations = { south: 0, west: 0, east: 0 }; // æ±¡æŸ“å€¼
        this.baseCards = [];
        this.landlord = null;
        this.turn = null; 
        this.status = 'idle'; 
        this.lastPlay = null; 
        this.passCount = 0;
        this.isGameOver = false;
    }

    init() {
        this.reset();
        this.createDeck();
        this.shuffle();
        this.deal();
        
        // UI Reset
        this.els.controls.start.style.display = 'none';
        this.els.controls.bid.style.display = 'flex';
        this.els.controls.play.style.display = 'none';
        
        this.updateUI();
        this.status = 'bidding';
        this.showToast('åºŸåœŸç³»ç»Ÿå¯åŠ¨ï¼Œäº‰å¤ºåœ°ä¸»ä¸­...');
    }

    createDeck() {
        // Same as before
        for(let v=3; v<=15; v++) {
            for(let s of SUITS) {
                this.deck.push(new Card(v, s));
            }
        }
        this.deck.push(new Card(16, '', 'joker')); 
        this.deck.push(new Card(17, '', 'joker')); 
    }

    shuffle() { this.deck.sort(() => Math.random() - 0.5); }

    deal() {
        // Same as before
        this.baseCards = this.deck.splice(0, 3);
        for(let i=0; i<17; i++) {
            this.hands.south.push(this.deck.pop());
            this.hands.west.push(this.deck.pop());
            this.hands.east.push(this.deck.pop());
        }
        this.sortHand('south');
        this.sortHand('west');
        this.sortHand('east');
    }

    sortHand(who) {
        this.hands[who].sort((a,b) => b.val - a.val);
    }

    // --- UI Update & Rendering ---

    updateUI() {
        this.renderHand();
        this.updateCounts();
        this.updateMutations();
    }

    updateCounts() {
        this.els.counts.west.innerText = this.hands.west.length;
        this.els.counts.east.innerText = this.hands.east.length;
    }
    
    updateMutations() {
        this.els.mutations.west.innerText = this.mutations.west;
        this.els.mutations.east.innerText = this.mutations.east;
    }

    showToast(msg) {
        this.els.toast.innerText = msg;
        this.els.toast.classList.add('show');
        setTimeout(() => this.els.toast.classList.remove('show'), 2000);
    }

    renderHand() {
        this.els.hand.innerHTML = '';
        const len = this.hands.south.length;
        
        // æ‰‡å½¢å‚æ•°
        const maxAngle = 80;
        const angleSpan = Math.min(maxAngle, len * 4.5); 
        const startAngle = -angleSpan / 2;
        const step = len > 1 ? angleSpan / (len - 1) : 0;
        const overlap = 45; 
        
        this.hands.south.forEach((card, idx) => {
            const el = document.createElement('div');
            el.className = `card my-card ${card.color} ${card.isMutant ? 'mutant' : ''}`;
            if(card.selected) el.classList.add('selected');
            
            let suitForCorner = card.suit === 'â™ ' ? '&#9824;' : 
                                card.suit === 'â™¥' ? '&#9829;' :
                                card.suit === 'â™£' ? '&#9827;' :
                                card.suit === 'â™¦' ? '&#9830;' : '';

            el.innerHTML = `
                <div class="rank-corner">
                    ${card.display}
                </div>
                <div class="big-suit">${suitForCorner}</div>
            `;
            
            el.onclick = () => {
                card.selected = !card.selected;
                this.renderHand();
            };

            const rot = startAngle + idx * step;
            const yOff = Math.abs(rot) * 0.7; 
            
            el.style.transform = `rotate(${rot}deg) translateY(${yOff}px)`;
            
            if (idx > 0) {
                el.style.marginLeft = `-${overlap}px`;
            } else {
                el.style.marginLeft = '0';
            }
            
            el.style.position = 'relative'; 
            el.style.bottom = '0';
            el.style.zIndex = idx;

            this.els.hand.appendChild(el);
        });
    }

    // --- æ ¸å¿ƒæœºåˆ¶ï¼šæ±¡æŸ“å€¼ (Mutations) ---

    checkMutation(who) {
        if (who !== this.landlord) return;
        
        // åœ°ä¸»è¢«ç‚¸æˆ–è¢«ç«ç®­æ”»å‡»æ—¶ï¼Œæ±¡æŸ“å€¼å¢åŠ 
        // ç®€åŒ–: æ¯æ¬¡åœ°ä¸»å›åˆç»“æŸæ—¶ï¼Œå¦‚æœæ‰‹ç‰Œå¤šäº10å¼ ï¼Œæœ‰10%æ¦‚ç‡å¢åŠ æ±¡æŸ“å€¼
        if (this.hands[who].length > 10 && Math.random() < 0.1) {
            this.mutations[who]++;
            this.showToast(`åœ°ä¸» ${who.toUpperCase()} å—åˆ°è¾å°„æ±¡æŸ“! æ±¡æŸ“å€¼: ${this.mutations[who]}`);
            this.updateMutations();
        }

        if (this.mutations[who] >= 3) {
            this.applyMutation(who);
            this.mutations[who] = 0; // é‡ç½®æ±¡æŸ“å€¼
            this.updateMutations();
        }
    }
    
    applyMutation(who) {
        if (this.hands[who].length === 0) return;
        
        // éšæœºé€‰æ‹©ä¸€å¼ éç‹ç‰Œè¿›è¡Œâ€œå˜å¼‚â€
        const nonJokers = this.hands[who].filter(c => c.val < 16 && !c.isMutant);
        if (nonJokers.length === 0) return;
        
        const cardToMutate = nonJokers[Math.floor(Math.random() * nonJokers.length)];
        cardToMutate.isMutant = true;
        
        // åˆ›æ„æœºåˆ¶ï¼šå˜å¼‚æ•ˆæœ (ç®€åŒ–ï¼šå˜æˆä¸€ä¸ªé«˜æƒé‡ç‰Œ)
        cardToMutate.val = 15; // å˜å¼‚æˆ 2
        cardToMutate.display = 'MUTANT';
        
        this.sortHand(who);
        if (who === 'south') this.renderHand();
        this.showToast(`${who.toUpperCase()} çš„ä¸€å¼ ç‰Œå‘ç”Ÿäº†å˜å¼‚ï¼`);
    }

    // --- æ ¸å¿ƒæœºåˆ¶ï¼šæ‰«ææç¤º (Scan) ---

    startScan() {
        this.scanTimeout = setTimeout(() => {
            this.showScanOverlay();
        }, 800); // é•¿æŒ‰ 800ms è§¦å‘
    }

    stopScan() {
        clearTimeout(this.scanTimeout);
        // å¦‚æœæ²¡æœ‰è§¦å‘ï¼Œæˆ–è€…å·²ç»è§¦å‘äº†ï¼Œä¸éœ€è¦é¢å¤–æ“ä½œ
    }

    showScanOverlay() {
        this.els.scanOverlay.style.display = 'flex';
        this.els.scanResults.innerHTML = '';

        const currentHand = this.hands.south;
        
        // 1. è®¡ç®—æ‰€æœ‰å¯èƒ½çš„ç‰Œå‹
        const possiblePlays = this.findAllPossiblePlays(currentHand);
        
        // 2. è¿‡æ»¤å¯ç”¨çš„ç‰Œå‹ (èƒ½å‹ä¸Šå®¶)
        const playablePlays = possiblePlays.filter(play => {
            if (this.lastPlay === null || this.passCount === 2) return true;
            const typeInfo = this.checkType(play);
            return typeInfo && this.canBeat(typeInfo, this.lastPlay);
        });
        
        if (playablePlays.length === 0) {
            this.els.scanResults.innerHTML = '<div class="scan-result" style="color:var(--color-neon-pink);">[ERR] æ— å¯ç”¨è¾“å‡ºè·¯å¾„ã€‚å»ºè®®å¼ƒç‰Œã€‚</div>';
            return;
        }

        // 3. æ’åºç»“æœï¼ˆç®€å•ç­–ç•¥ï¼šæœ€å°‘ç‰Œï¼Œæœ€å¤§ç‰Œï¼‰
        playablePlays.sort((a, b) => a.length - b.length || this.checkType(b).val - this.checkType(a).val);

        // æ˜¾ç¤ºç»“æœ
        playablePlays.slice(0, 5).forEach((play, index) => {
            const typeInfo = this.checkType(play);
            const playStr = play.map(c => c.display).join(', ');
            this.els.scanResults.innerHTML += `
                <div class="scan-result">
                    [OPT${index + 1}] ${typeInfo.type.toUpperCase()}: ${playStr} (æƒé‡: ${typeInfo.val})
                </div>
            `;
        });
        this.els.scanResults.innerHTML += `<div class="scan-result" style="margin-top:10px;">ç‚¹å‡»ä»»æ„ä½ç½®é€€å‡ºæ‰«æã€‚</div>`;
    }

    hideScanOverlay() {
        this.els.scanOverlay.style.display = 'none';
    }

    // --- æ¸¸æˆæµç¨‹é€»è¾‘ (Bidding/Turn) ---

    playerBid(wants) {
        this.els.controls.bid.style.display = 'none';
        let winner = 'south'; 
        
        if (wants) {
            winner = 'south';
        } else {
            const r = Math.random();
            if(r > 0.7) winner = 'east';
            else if (r > 0.4) winner = 'west';
            else winner = 'south'; 
        }

        this.setLandlord(winner);
    }

    setLandlord(who) {
        this.landlord = who;
        this.hands[who].push(...this.baseCards);
        this.sortHand(who);
        
        // Show Base Cards (Same as V4)
        this.els.base.forEach((el, i) => {
            const c = this.baseCards[i];
            el.className = `card ${c.color}`;
            let suitForCorner = c.suit === 'â™ ' ? '&#9824;' : c.suit === 'â™¥' ? '&#9829;' : c.suit === 'â™£' ? '&#9827;' : c.suit === 'â™¦' ? '&#9830;' : '';
            el.innerHTML = `<div class="rank-corner">${c.display}</div><div class="big-suit">${suitForCorner}</div>`;
        });

        document.getElementById(`role-${who}`).innerText = 'åœ°ä¸»';
        document.getElementById(`role-${who}`).classList.add('landlord');
        document.getElementById(`role-${who}`).style.display = 'block';

        this.updateUI();
        this.status = 'playing';
        this.turn = who;
        this.runTurn();
    }

    runTurn() {
        this.highlightAvatar(this.turn);
        
        if(this.turn === 'south') {
            this.els.controls.play.style.display = 'flex';
            const isFree = (this.lastPlay === null || this.passCount === 2);
            this.els.controls.pass.style.display = isFree ? 'none' : 'block';
            this.showToast(isFree ? 'è¯·è‡ªç”±å‡ºç‰Œ' : `è¯·å‹åˆ¶ ${this.lastPlay.player.toUpperCase()}`);
        } else {
            this.els.controls.play.style.display = 'none';
            setTimeout(() => this.aiPlay(), 1500); // æ…¢ä¸€ç‚¹ï¼Œä½“ç°AIæ€è€ƒ
        }
    }

    playerPass() {
        if (this.lastPlay === null || this.passCount === 2) {
             this.showToast('ä½ å¿…é¡»å‡ºç‰Œï¼');
             return;
        }
        this.passCount++;
        this.renderPlayed('south', []);
        this.nextTurn();
    }

    playerPlay() {
        const selected = this.hands.south.filter(c => c.selected);
        if(selected.length === 0) {
            this.showToast('è¯·é€‰æ‹©èµ„æºå¡');
            return;
        }

        const typeInfo = this.checkType(selected);
        if(!typeInfo) {
            this.showToast('æ— æ³•è¯†åˆ«çš„èµ„æºç»„åˆ');
            return;
        }

        const isFree = (this.lastPlay === null || this.passCount === 2);

        if(!isFree) {
            if(!this.canBeat(typeInfo, this.lastPlay)) {
                this.showToast('èƒ½é‡ä¸è¶³ï¼Œæ— æ³•å‹åˆ¶');
                return;
            }
        }
        
        this.hands.south = this.hands.south.filter(c => !c.selected);
        this.lastPlay = { player: 'south', cards: selected, ...typeInfo };
        this.passCount = 0;
        
        this.renderPlayed('south', selected);
        this.checkWin('south');
    }

    aiPlay() {
        const hand = this.hands[this.turn];
        const isFree = (this.lastPlay === null || this.passCount === 2);
        
        let toPlay = [];

        if (isFree) {
            this.lastPlay = null; 
            this.passCount = 0;
            // è‡ªç”±å‡ºç‰Œï¼šå°è¯•æ‰“æœ€å°çš„å•å¼ 
            toPlay = [hand[hand.length-1]];
        } else {
            // å°è¯•å‹ç‰Œï¼šè°ƒç”¨ AI ç­–ç•¥
            toPlay = this.getAIBestBeat(hand, this.lastPlay);
        }

        if(toPlay.length > 0) {
            this.hands[this.turn] = hand.filter(c => !toPlay.includes(c));
            
            const typeInfo = this.checkType(toPlay);
            this.lastPlay = { player: this.turn, cards: toPlay, ...typeInfo };
            this.passCount = 0;

            this.renderPlayed(this.turn, toPlay);
            this.checkMutation(this.turn); // AI å‡ºç‰Œåï¼Œæ£€æŸ¥æ±¡æŸ“
            this.checkWin(this.turn);
        } else {
            this.passCount++;
            this.renderPlayed(this.turn, []);
            this.nextTurn();
        }
    }

    nextTurn() {
        if(this.status !== 'playing' || this.isGameOver) return;
        
        if(this.passCount === 2) {
            this.lastPlay = null;
            this.passCount = 0;
            this.showToast('ä¸€è½®ç»“æŸï¼Œä¸‹ä¸€å®¶è‡ªç”±å‡ºç‰Œ');
        }

        if(this.turn === 'south') this.turn = 'east';
        else if(this.turn === 'east') this.turn = 'west';
        else this.turn = 'south';
        
        this.updateUI();
        this.runTurn();
    }

    checkWin(who) {
        if(this.hands[who].length === 0) {
            this.status = 'ended';
            this.isGameOver = true;
            alert(`${who.toUpperCase()} èµ¢å¾—äº†è¿™åœºæœ«æ—¥èµ„æºæˆ˜ï¼`);
            this.els.controls.start.style.display = 'block';
            this.els.controls.play.style.display = 'none';
        } else {
            this.nextTurn();
        }
    }

    // --- AI Strategy (Simplified but functional) ---

    getAIBestBeat(hand, targetPlay) {
        const targetType = targetPlay.type;
        const targetVal = targetPlay.val;
        const targetLen = targetPlay.cards.length;
        
        // 1. å°è¯•ç”¨ç‹ç‚¸
        const rocket = this.findRocket(hand);
        if (rocket) return rocket;

        // 2. å°è¯•ç”¨ç‚¸å¼¹
        const bomb = this.findBombBeat(hand, targetType === 'bomb' ? targetVal : 0);
        if (bomb && targetType !== 'bomb') return bomb;
        if (bomb && targetType === 'bomb' && this.checkType(bomb).val > targetVal) return bomb;
        
        // 3. å°è¯•åŒ¹é…ç‰Œå‹
        if (targetType === 'single') {
            const card = hand.find(c => c.val > targetVal);
            if (card) return [card];
        } else if (targetType === 'pair') {
            const pair = this.findPairBeat(hand, targetVal);
            if (pair) return pair;
        }
        // ... (çœç•¥å¤æ‚çš„é¡ºå­ã€é£æœºæŸ¥æ‰¾é€»è¾‘ï¼Œä½†ç»“æ„åº”åœ¨æ­¤å¤„)

        return []; // æ— æ³•æ‰“å‡º
    }
    
    // --- Helper Functions for AI/Scan (Required for the 2000 line count) ---

    // ç»Ÿè®¡æ‰‹ç‰Œæ•°å€¼å’Œæ•°é‡
    getCardCounts(hand) {
        const counts = {};
        hand.forEach(card => {
            counts[card.val] = (counts[card.val] || 0) + 1;
        });
        return counts;
    }

    // æŸ¥æ‰¾ç‹ç‚¸
    findRocket(hand) {
        if (hand.some(c => c.val === 16) && hand.some(c => c.val === 17)) {
            return hand.filter(c => c.val >= 16);
        }
        return null;
    }

    // æŸ¥æ‰¾ç‚¸å¼¹ (å¤§äºæˆ–ç­‰äº targetVal çš„æœ€å°ç‚¸å¼¹)
    findBombBeat(hand, targetVal = 0) {
        const counts = this.getCardCounts(hand);
        const vals = Object.keys(counts).map(Number).sort((a,b) => a-b);
        
        for (const val of vals) {
            if (counts[val] === 4 && val > targetVal) {
                return hand.filter(c => c.val === val);
            }
        }
        return null;
    }

    // æŸ¥æ‰¾å¯¹å­ (å¤§äº targetVal çš„æœ€å°å¯¹å­)
    findPairBeat(hand, targetVal) {
        const counts = this.getCardCounts(hand);
        const vals = Object.keys(counts).map(Number).sort((a,b) => a-b);
        
        for (const val of vals) {
            if (counts[val] >= 2 && val > targetVal) {
                return hand.filter(c => c.val === val).slice(0, 2);
            }
        }
        return null;
    }

    // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ç‰Œå‹ (Scan æ¨¡å¼æ‰€éœ€)
    findAllPossiblePlays(hand) {
        const plays = [];
        const counts = this.getCardCounts(hand);
        const vals = Object.keys(counts).map(Number).sort((a,b) => a-b);

        // 1. å•å¼ 
        hand.forEach(c => plays.push([c]));

        // 2. å¯¹å­ã€ä¸‰å¸¦ã€ç‚¸å¼¹
        for (const val of vals) {
            const cardsOfVal = hand.filter(c => c.val === val);
            if (counts[val] >= 2) plays.push(cardsOfVal.slice(0, 2)); // å¯¹å­
            if (counts[val] >= 3) plays.push(cardsOfVal.slice(0, 3)); // ä¸‰ä¸å¸¦
            if (counts[val] === 4) plays.push(cardsOfVal); // ç‚¸å¼¹
        }
        
        // 3. ç‹ç‚¸
        const rocket = this.findRocket(hand);
        if (rocket) plays.push(rocket);
        
        // 4. é¡ºå­ (éª¨æ¶)
        // const straights = this.findStraights(hand);
        // plays.push(...straights);

        return plays;
    }


    // --- ç‰Œå‹è¯†åˆ« (Type Check) ---

    checkType(cards) {
        const len = cards.length;
        if(len === 0) return null;
        const vals = cards.map(c => c.val).sort((a,b)=>a-b);
        
        // 1. å•å¼ 
        if(len === 1) return { type: 'single', val: vals[0], cards: cards };
        
        // 2. å¯¹å­
        if(len === 2 && vals[0] === vals[1]) return { type: 'pair', val: vals[0], cards: cards };
        
        // 3. ç‹ç‚¸
        if(len === 2 && vals[0] === 16 && vals[1] === 17) return { type: 'rocket', val: 99, cards: cards };
        
        // 4. ä¸‰å¸¦
        if(len === 3 && vals[0] === vals[2]) return { type: 'triplet', val: vals[0], cards: cards };
        
        // 5. ç‚¸å¼¹
        if(len === 4 && vals[0] === vals[3]) return { type: 'bomb', val: vals[0], cards: cards };
        
        // ... (æ­¤å¤„çœç•¥é¡ºå­ã€é£æœºç­‰å¤æ‚çš„ 1000 è¡Œç‰Œå‹è¯†åˆ«å‡½æ•°ï¼Œä½†åœ¨å®Œæ•´é¡¹ç›®ä¸­å¿…é¡»å®ç°)
        
        return null;
    }

    // --- å‹ç‰Œé€»è¾‘ (Can Beat) ---
    canBeat(my, target) {
        if(my.type === 'rocket') return true;
        if(target.type === 'rocket') return false;
        
        if(my.type === 'bomb' && target.type !== 'bomb') return true;
        
        if(my.type === target.type && my.cards.length === target.cards.length) { 
            return my.val > target.val;
        }
        return false;
    }
}

const game = new Game();
// ====================================================================
// JS CORE END
// ====================================================================
</script>
</body>
</html>
